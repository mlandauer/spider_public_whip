#!/usr/bin/env ruby

# Run this _after_ running spider. It uses the csv file links.csv from the previous step

require 'csv'

def read_paths_from_file
  urls = []
  CSV.foreach("links.csv") do |row|
    urls << row[2]
  end
  urls[1..-1].map do |url|
    u = URI.parse(url)
    path = u.path
    path += "?" + u.query if u.query
    path
  end
end

def normalise_html(text)
  tidy(text)
end

def normalise_xml(text)
  tidy(text, :xml)
end

def tidy(text, format = :html)
  File.open("temp", "w") {|f| f.write(text) }
  # Requires HTML Tidy (http://tidy.sourceforge.net/) version 14 June 2007 or later
  # Note the version installed with OS X by default is a version that's too old
  # Install on OS X with "brew install tidy"
  command = "#{tidy_path}#{' -xml' if format == :xml} --show-warnings no --sort-attributes alpha -utf8 -q -m temp"
  if system(command).nil? || $?.exitstatus > 1 #tidy is stupid and returns 1 on warning, 2 on failure.
    raise "tidy command failed '#{command}'"
  end

  r = File.read("temp")
  # Make sure that comments of the form <!-- comment --> are followed by a new line
  File.delete("temp")
  r.gsub("--><", "-->\n<")
end

def tidy_path
  # On OS X use tidy installed with Homebrew in preference to any other
  # It would normally be first in the path but we can't depend on that being the case here
  if File.exists? "/usr/local/bin/tidy"
    "/usr/local/bin/tidy"
  else
    "tidy"
  end
end

# These paths all go direct (or redirect) to login/registration pages
paths_to_skip = ["/account/addpolicy.php", "/account/lostpass.php", "/account/register.php?",
  "/account/settings.php", "/account/settings.php?",
  /\/account\/wiki.php/]

host1 = "localhost:8080"
host2 = "localhost:3000"

# Remove certain paths
paths = read_paths_from_file
paths_to_skip.each do |path|
  if path.kind_of?(String)
    paths.delete(path)
  elsif path.kind_of?(Regexp)
    paths.delete_if{|p| p =~ path }
  else
    raise "unexpected type"
  end
end
#paths = paths - paths_to_skip

paths.each do |path|
  puts "Checking #{path}..."
  text1 = Net::HTTP.get(URI.parse("http://#{host1}#{path}"))
  text2 = Net::HTTP.get(URI.parse("http://#{host2}#{path}"))
  text1.force_encoding(Encoding::UTF_8)
  text2.force_encoding(Encoding::UTF_8)
  n1 = normalise_html(text1)
  n2 = normalise_html(text2)
  if n1 != n2
    puts "Not matching"
    exit
  end
end
